{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global[\"fast-equals\"] = {}));\n})(this, function (exports) {\n  'use strict';\n  /**\r\n   * Default equality comparator pass-through, used as the standard `isEqual` creator for\r\n   * use inside the built comparator.\r\n   */\n\n  function createDefaultIsNestedEqual(comparator) {\n    return function isEqual(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, meta) {\n      return comparator(a, b, meta);\n    };\n  }\n  /**\r\n   * Wrap the provided `areItemsEqual` method to manage the circular cache, allowing\r\n   * for circular references to be safely included in the comparison without creating\r\n   * stack overflows.\r\n   */\n\n\n  function createIsCircular(areItemsEqual) {\n    return function isCircular(a, b, isEqual, cache) {\n      if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\n        return areItemsEqual(a, b, isEqual, cache);\n      }\n\n      var cachedA = cache.get(a);\n      var cachedB = cache.get(b);\n\n      if (cachedA && cachedB) {\n        return cachedA === b && cachedB === a;\n      }\n\n      cache.set(a, b);\n      cache.set(b, a);\n      var result = areItemsEqual(a, b, isEqual, cache);\n      cache.delete(a);\n      cache.delete(b);\n      return result;\n    };\n  }\n  /**\r\n   * Targeted shallow merge of two objects.\r\n   *\r\n   * @NOTE\r\n   * This exists as a tinier compiled version of the `__assign` helper that\r\n   * `tsc` injects in case of `Object.assign` not being present.\r\n   */\n\n\n  function merge(a, b) {\n    var merged = {};\n\n    for (var key in a) {\n      merged[key] = a[key];\n    }\n\n    for (var key in b) {\n      merged[key] = b[key];\n    }\n\n    return merged;\n  }\n  /**\r\n   * Whether the value is a plain object.\r\n   *\r\n   * @NOTE\r\n   * This is a same-realm compariosn only.\r\n   */\n\n\n  function isPlainObject(value) {\n    return value.constructor === Object || value.constructor == null;\n  }\n  /**\r\n   * When the value is `Promise`-like, aka \"then-able\".\r\n   */\n\n\n  function isPromiseLike(value) {\n    return typeof value.then === 'function';\n  }\n  /**\r\n   * Whether the values passed are strictly equal or both NaN.\r\n   */\n\n\n  function sameValueZeroEqual(a, b) {\n    return a === b || a !== a && b !== b;\n  }\n\n  var ARGUMENTS_TAG = '[object Arguments]';\n  var BOOLEAN_TAG = '[object Boolean]';\n  var DATE_TAG = '[object Date]';\n  var REG_EXP_TAG = '[object RegExp]';\n  var MAP_TAG = '[object Map]';\n  var NUMBER_TAG = '[object Number]';\n  var OBJECT_TAG = '[object Object]';\n  var SET_TAG = '[object Set]';\n  var STRING_TAG = '[object String]';\n  var toString = Object.prototype.toString;\n\n  function createComparator(_a) {\n    var areArraysEqual = _a.areArraysEqual,\n        areDatesEqual = _a.areDatesEqual,\n        areMapsEqual = _a.areMapsEqual,\n        areObjectsEqual = _a.areObjectsEqual,\n        areRegExpsEqual = _a.areRegExpsEqual,\n        areSetsEqual = _a.areSetsEqual,\n        createIsNestedEqual = _a.createIsNestedEqual;\n    var isEqual = createIsNestedEqual(comparator);\n    /**\r\n     * compare the value of the two objects and return true if they are equivalent in values\r\n     */\n\n    function comparator(a, b, meta) {\n      // If the items are strictly equal, no need to do a value comparison.\n      if (a === b) {\n        return true;\n      } // If the items are not non-nullish objects, then the only possibility\n      // of them being equal but not strictly is if they are both `NaN`. Since\n      // `NaN` is uniquely not equal to itself, we can use self-comparison of\n      // both objects, which is faster than `isNaN()`.\n\n\n      if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\n        return a !== a && b !== b;\n      } // Checks are listed in order of commonality of use-case:\n      //   1. Common complex object types (plain object, array)\n      //   2. Common data values (date, regexp)\n      //   3. Less-common complex object types (map, set)\n      //   4. Less-common data values (promise, primitive wrappers)\n      // Inherently this is both subjective and assumptive, however\n      // when reviewing comparable libraries in the wild this order\n      // appears to be generally consistent.\n      // `isPlainObject` only checks against the object's own realm. Cross-realm\n      // comparisons are rare, and will be handled in the ultimate fallback, so\n      // we can avoid the `toString.call()` cost unless necessary.\n\n\n      if (isPlainObject(a) && isPlainObject(b)) {\n        return areObjectsEqual(a, b, isEqual, meta);\n      } // `isArray()` works on subclasses and is cross-realm, so we can again avoid\n      // the `toString.call()` cost unless necessary by just checking if either\n      // and then both are arrays.\n\n\n      var aArray = Array.isArray(a);\n      var bArray = Array.isArray(b);\n\n      if (aArray || bArray) {\n        return aArray === bArray && areArraysEqual(a, b, isEqual, meta);\n      } // Since this is a custom object, use the classic `toString.call()` to get its\n      // type. This is reasonably performant in modern environments like v8 and\n      // SpiderMonkey, and allows for cross-realm comparison when other checks like\n      // `instanceof` do not.\n\n\n      var aTag = toString.call(a);\n\n      if (aTag !== toString.call(b)) {\n        return false;\n      }\n\n      if (aTag === DATE_TAG) {\n        // `getTime()` showed better results compared to alternatives like `valueOf()`\n        // or the unary `+` operator.\n        return areDatesEqual(a, b, isEqual, meta);\n      }\n\n      if (aTag === REG_EXP_TAG) {\n        return areRegExpsEqual(a, b, isEqual, meta);\n      }\n\n      if (aTag === MAP_TAG) {\n        return areMapsEqual(a, b, isEqual, meta);\n      }\n\n      if (aTag === SET_TAG) {\n        return areSetsEqual(a, b, isEqual, meta);\n      } // If a simple object tag, then we can prioritize a simple object comparison because\n      // it is likely a custom class. If an arguments tag, it should be treated as a standard\n      // object.\n\n\n      if (aTag === OBJECT_TAG || aTag === ARGUMENTS_TAG) {\n        // The exception for value comparison is `Promise`-like contracts. These should be\n        // treated the same as standard `Promise` objects, which means strict equality.\n        return isPromiseLike(a) || isPromiseLike(b) ? false : areObjectsEqual(a, b, isEqual, meta);\n      } // As the penultimate fallback, check if the values passed are primitive wrappers. This\n      // is very rare in modern JS, which is why it is deprioritized compared to all other object\n      // types.\n\n\n      if (aTag === BOOLEAN_TAG || aTag === NUMBER_TAG || aTag === STRING_TAG) {\n        return sameValueZeroEqual(a.valueOf(), b.valueOf());\n      } // If not matching any tags that require a specific type of comparison, then we hard-code false because\n      // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\n      //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\n      //     comparison that can be made.\n      //   - For types that can be introspected, but rarely have requirements to be compared\n      //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\n      //     use-cases (may be included in a future release, if requested enough).\n      //   - For types that can be introspected but do not have an objective definition of what\n      //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\n      // In all cases, these decisions should be reevaluated based on changes to the language and\n      // common development practices.\n\n\n      return false;\n    }\n\n    return comparator;\n  }\n  /**\r\n   * Whether the arrays are equal in value.\r\n   */\n\n\n  function areArraysEqual(a, b, isEqual, meta) {\n    var index = a.length;\n\n    if (b.length !== index) {\n      return false;\n    } // Decrementing `while` showed faster results than either incrementing or\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\n    // methods like `some` / `every` were not used to avoid incurring the garbage\n    // cost of anonymous callbacks.\n\n\n    while (index-- > 0) {\n      if (!isEqual(a[index], b[index], index, index, a, b, meta)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\r\n   * Whether the arrays are equal in value, including circular references.\r\n   */\n\n\n  var areArraysEqualCircular = createIsCircular(areArraysEqual);\n  /**\r\n   * Whether the dates passed are equal in value.\r\n   *\r\n   * @NOTE\r\n   * This is a standalone function instead of done inline in the comparator\r\n   * to allow for overrides.\r\n   */\n\n  function areDatesEqual(a, b) {\n    return sameValueZeroEqual(a.valueOf(), b.valueOf());\n  }\n  /**\r\n   * Whether the `Map`s are equal in value.\r\n   */\n\n\n  function areMapsEqual(a, b, isEqual, meta) {\n    var isValueEqual = a.size === b.size;\n\n    if (!isValueEqual) {\n      return false;\n    }\n\n    if (!a.size) {\n      return true;\n    } // The use of `forEach()` is to avoid the transpilation cost of `for...of` comparisons, and\n    // the inability to control the performance of the resulting code. It also avoids excessive\n    // iteration compared to doing comparisons of `keys()` and `values()`. As a result, though,\n    // we cannot short-circuit the iterations; bookkeeping must be done to short-circuit the\n    // equality checks themselves.\n\n\n    var matchedIndices = {};\n    var indexA = 0;\n    a.forEach(function (aValue, aKey) {\n      if (!isValueEqual) {\n        return;\n      }\n\n      var hasMatch = false;\n      var matchIndexB = 0;\n      b.forEach(function (bValue, bKey) {\n        if (!hasMatch && !matchedIndices[matchIndexB] && (hasMatch = isEqual(aKey, bKey, indexA, matchIndexB, a, b, meta) && isEqual(aValue, bValue, aKey, bKey, a, b, meta))) {\n          matchedIndices[matchIndexB] = true;\n        }\n\n        matchIndexB++;\n      });\n      indexA++;\n      isValueEqual = hasMatch;\n    });\n    return isValueEqual;\n  }\n  /**\r\n   * Whether the `Map`s are equal in value, including circular references.\r\n   */\n\n\n  var areMapsEqualCircular = createIsCircular(areMapsEqual);\n  var OWNER = '_owner';\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  /**\r\n   * Whether the objects are equal in value.\r\n   */\n\n  function areObjectsEqual(a, b, isEqual, meta) {\n    var keysA = Object.keys(a);\n    var index = keysA.length;\n\n    if (Object.keys(b).length !== index) {\n      return false;\n    }\n\n    var key; // Decrementing `while` showed faster results than either incrementing or\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\n    // methods like `some` / `every` were not used to avoid incurring the garbage\n    // cost of anonymous callbacks.\n\n    while (index-- > 0) {\n      key = keysA[index];\n\n      if (key === OWNER) {\n        var reactElementA = !!a.$$typeof;\n        var reactElementB = !!b.$$typeof;\n\n        if ((reactElementA || reactElementB) && reactElementA !== reactElementB) {\n          return false;\n        }\n      }\n\n      if (!hasOwnProperty.call(b, key) || !isEqual(a[key], b[key], key, key, a, b, meta)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\r\n   * Whether the objects are equal in value, including circular references.\r\n   */\n\n\n  var areObjectsEqualCircular = createIsCircular(areObjectsEqual);\n  /**\r\n   * Whether the regexps passed are equal in value.\r\n   *\r\n   * @NOTE\r\n   * This is a standalone function instead of done inline in the comparator\r\n   * to allow for overrides. An example of this would be supporting a\r\n   * pre-ES2015 environment where the `flags` property is not available.\r\n   */\n\n  function areRegExpsEqual(a, b) {\n    return a.source === b.source && a.flags === b.flags;\n  }\n  /**\r\n   * Whether the `Set`s are equal in value.\r\n   */\n\n\n  function areSetsEqual(a, b, isEqual, meta) {\n    var isValueEqual = a.size === b.size;\n\n    if (!isValueEqual) {\n      return false;\n    }\n\n    if (!a.size) {\n      return true;\n    } // The use of `forEach()` is to avoid the transpilation cost of `for...of` comparisons, and\n    // the inability to control the performance of the resulting code. It also avoids excessive\n    // iteration compared to doing comparisons of `keys()` and `values()`. As a result, though,\n    // we cannot short-circuit the iterations; bookkeeping must be done to short-circuit the\n    // equality checks themselves.\n\n\n    var matchedIndices = {};\n    a.forEach(function (aValue, aKey) {\n      if (!isValueEqual) {\n        return;\n      }\n\n      var hasMatch = false;\n      var matchIndex = 0;\n      b.forEach(function (bValue, bKey) {\n        if (!hasMatch && !matchedIndices[matchIndex] && (hasMatch = isEqual(aValue, bValue, aKey, bKey, a, b, meta))) {\n          matchedIndices[matchIndex] = true;\n        }\n\n        matchIndex++;\n      });\n      isValueEqual = hasMatch;\n    });\n    return isValueEqual;\n  }\n  /**\r\n   * Whether the `Set`s are equal in value, including circular references.\r\n   */\n\n\n  var areSetsEqualCircular = createIsCircular(areSetsEqual);\n  var DEFAULT_CONFIG = Object.freeze({\n    areArraysEqual: areArraysEqual,\n    areDatesEqual: areDatesEqual,\n    areMapsEqual: areMapsEqual,\n    areObjectsEqual: areObjectsEqual,\n    areRegExpsEqual: areRegExpsEqual,\n    areSetsEqual: areSetsEqual,\n    createIsNestedEqual: createDefaultIsNestedEqual\n  });\n  var DEFAULT_CIRCULAR_CONFIG = Object.freeze({\n    areArraysEqual: areArraysEqualCircular,\n    areDatesEqual: areDatesEqual,\n    areMapsEqual: areMapsEqualCircular,\n    areObjectsEqual: areObjectsEqualCircular,\n    areRegExpsEqual: areRegExpsEqual,\n    areSetsEqual: areSetsEqualCircular,\n    createIsNestedEqual: createDefaultIsNestedEqual\n  });\n  var isDeepEqual = createComparator(DEFAULT_CONFIG);\n  /**\r\n   * Whether the items passed are deeply-equal in value.\r\n   */\n\n  function deepEqual(a, b) {\n    return isDeepEqual(a, b, undefined);\n  }\n\n  var isShallowEqual = createComparator(merge(DEFAULT_CONFIG, {\n    createIsNestedEqual: function () {\n      return sameValueZeroEqual;\n    }\n  }));\n  /**\r\n   * Whether the items passed are shallowly-equal in value.\r\n   */\n\n  function shallowEqual(a, b) {\n    return isShallowEqual(a, b, undefined);\n  }\n\n  var isCircularDeepEqual = createComparator(DEFAULT_CIRCULAR_CONFIG);\n  /**\r\n   * Whether the items passed are deeply-equal in value, including circular references.\r\n   */\n\n  function circularDeepEqual(a, b) {\n    return isCircularDeepEqual(a, b, new WeakMap());\n  }\n\n  var isCircularShallowEqual = createComparator(merge(DEFAULT_CIRCULAR_CONFIG, {\n    createIsNestedEqual: function () {\n      return sameValueZeroEqual;\n    }\n  }));\n  /**\r\n   * Whether the items passed are shallowly-equal in value, including circular references.\r\n   */\n\n  function circularShallowEqual(a, b) {\n    return isCircularShallowEqual(a, b, new WeakMap());\n  }\n  /**\r\n   * Create a custom equality comparison method.\r\n   *\r\n   * This can be done to create very targeted comparisons in extreme hot-path scenarios\r\n   * where the standard methods are not performant enough, but can also be used to provide\r\n   * support for legacy environments that do not support expected features like\r\n   * `RegExp.prototype.flags` out of the box.\r\n   */\n\n\n  function createCustomEqual(getComparatorOptions) {\n    return createComparator(merge(DEFAULT_CONFIG, getComparatorOptions(DEFAULT_CONFIG)));\n  }\n  /**\r\n   * Create a custom equality comparison method that handles circular references. This is very\r\n   * similar to `createCustomEqual`, with the only difference being that `meta` expects to be\r\n   * populated with a `WeakMap`-like contract.\r\n   *\r\n   * This can be done to create very targeted comparisons in extreme hot-path scenarios\r\n   * where the standard methods are not performant enough, but can also be used to provide\r\n   * support for legacy environments that do not support expected features like\r\n   * `WeakMap` out of the box.\r\n   */\n\n\n  function createCustomCircularEqual(getComparatorOptions) {\n    var comparator = createComparator(merge(DEFAULT_CIRCULAR_CONFIG, getComparatorOptions(DEFAULT_CIRCULAR_CONFIG)));\n    return function (a, b, meta) {\n      if (meta === void 0) {\n        meta = new WeakMap();\n      }\n\n      return comparator(a, b, meta);\n    };\n  }\n\n  exports.circularDeepEqual = circularDeepEqual;\n  exports.circularShallowEqual = circularShallowEqual;\n  exports.createCustomCircularEqual = createCustomCircularEqual;\n  exports.createCustomEqual = createCustomEqual;\n  exports.deepEqual = deepEqual;\n  exports.sameValueZeroEqual = sameValueZeroEqual;\n  exports.shallowEqual = shallowEqual;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"mappings":"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","names":["createDefaultIsNestedEqual","comparator","isEqual","a","b","_indexOrKeyA","_indexOrKeyB","_parentA","_parentB","meta","createIsCircular","areItemsEqual","isCircular","cache","cachedA","get","cachedB","set","result","delete","merged","key","isPlainObject","value","constructor","Object","isPromiseLike","then","ARGUMENTS_TAG","BOOLEAN_TAG","DATE_TAG","REG_EXP_TAG","MAP_TAG","NUMBER_TAG","OBJECT_TAG","SET_TAG","STRING_TAG","prototype","toString","createComparator","_a","areDatesEqual","areMapsEqual","areObjectsEqual","areRegExpsEqual","areSetsEqual","createIsNestedEqual","aArray","Array","isArray","bArray","areArraysEqual","aTag","call","sameValueZeroEqual","valueOf","index","length","areArraysEqualCircular","isValueEqual","size","matchedIndices","indexA","forEach","aValue","aKey","hasMatch","matchIndexB","bValue","bKey","areMapsEqualCircular","OWNER","hasOwnProperty","keysA","keys","reactElementA","$$typeof","reactElementB","areObjectsEqualCircular","source","flags","matchIndex","areSetsEqualCircular","DEFAULT_CONFIG","freeze","DEFAULT_CIRCULAR_CONFIG","isDeepEqual","undefined","isShallowEqual","merge","isCircularDeepEqual","WeakMap","isCircularShallowEqual","createCustomEqual","getComparatorOptions","createCustomCircularEqual","exports"],"sources":["D:\\FE\\project\\qlsv_frontend\\node_modules\\fast-equals\\src\\utils.ts","D:\\FE\\project\\qlsv_frontend\\node_modules\\fast-equals\\src\\comparator.ts","D:\\FE\\project\\qlsv_frontend\\node_modules\\fast-equals\\src\\arrays.ts","D:\\FE\\project\\qlsv_frontend\\node_modules\\fast-equals\\src\\dates.ts","D:\\FE\\project\\qlsv_frontend\\node_modules\\fast-equals\\src\\maps.ts","D:\\FE\\project\\qlsv_frontend\\node_modules\\fast-equals\\src\\objects.ts","D:\\FE\\project\\qlsv_frontend\\node_modules\\fast-equals\\src\\regexps.ts","D:\\FE\\project\\qlsv_frontend\\node_modules\\fast-equals\\src\\sets.ts","D:\\FE\\project\\qlsv_frontend\\node_modules\\fast-equals\\src\\index.ts"],"sourcesContent":["import {\n  EqualityComparator,\n  InternalEqualityComparator,\n  TypeEqualityComparator,\n} from '../index.d';\n\n/**\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\n * use inside the built comparator.\n */\nexport function createDefaultIsNestedEqual<Meta>(\n  comparator: EqualityComparator<Meta>,\n): InternalEqualityComparator<Meta> {\n  return function isEqual<A, B>(\n    a: A,\n    b: B,\n    _indexOrKeyA: any,\n    _indexOrKeyB: any,\n    _parentA: any,\n    _parentB: any,\n    meta: Meta,\n  ) {\n    return comparator(a, b, meta);\n  };\n}\n\n/**\n * Wrap the provided `areItemsEqual` method to manage the circular cache, allowing\n * for circular references to be safely included in the comparison without creating\n * stack overflows.\n */\nexport function createIsCircular<\n  AreItemsEqual extends TypeEqualityComparator<any, any>,\n>(areItemsEqual: AreItemsEqual): AreItemsEqual {\n  return function isCircular(\n    a: any,\n    b: any,\n    isEqual: InternalEqualityComparator<WeakMap<any, any>>,\n    cache: WeakMap<any, any>,\n  ) {\n    if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\n      return areItemsEqual(a, b, isEqual, cache);\n    }\n\n    const cachedA = cache.get(a);\n    const cachedB = cache.get(b);\n\n    if (cachedA && cachedB) {\n      return cachedA === b && cachedB === a;\n    }\n\n    cache.set(a, b);\n    cache.set(b, a);\n\n    const result = areItemsEqual(a, b, isEqual, cache);\n\n    cache.delete(a);\n    cache.delete(b);\n\n    return result;\n  } as AreItemsEqual;\n}\n\n/**\n * Targeted shallow merge of two objects.\n *\n * @NOTE\n * This exists as a tinier compiled version of the `__assign` helper that\n * `tsc` injects in case of `Object.assign` not being present.\n */\nexport function merge<A extends object, B extends object>(a: A, b: B): A & B {\n  const merged: Record<string, any> = {};\n\n  for (const key in a) {\n    merged[key] = a[key];\n  }\n\n  for (const key in b) {\n    merged[key] = b[key];\n  }\n\n  return merged as A & B;\n}\n\n/**\n * Whether the value is a plain object.\n *\n * @NOTE\n * This is a same-realm compariosn only.\n */\nexport function isPlainObject(value: any): boolean {\n  return value.constructor === Object || value.constructor == null;\n}\n\n/**\n * When the value is `Promise`-like, aka \"then-able\".\n */\nexport function isPromiseLike(value: any): boolean {\n  return typeof value.then === 'function';\n}\n\n/**\n * Whether the values passed are strictly equal or both NaN.\n */\nexport function sameValueZeroEqual(a: any, b: any): boolean {\n  return a === b || (a !== a && b !== b);\n}\n","import { isPlainObject, isPromiseLike, sameValueZeroEqual } from './utils';\n\nimport type {\n  CreateComparatorCreatorOptions,\n  EqualityComparator,\n} from '../index.d';\n\nconst ARGUMENTS_TAG = '[object Arguments]';\nconst BOOLEAN_TAG = '[object Boolean]';\nconst DATE_TAG = '[object Date]';\nconst REG_EXP_TAG = '[object RegExp]';\nconst MAP_TAG = '[object Map]';\nconst NUMBER_TAG = '[object Number]';\nconst OBJECT_TAG = '[object Object]';\nconst SET_TAG = '[object Set]';\nconst STRING_TAG = '[object String]';\n\nconst { toString } = Object.prototype;\n\nexport function createComparator<Meta>({\n  areArraysEqual,\n  areDatesEqual,\n  areMapsEqual,\n  areObjectsEqual,\n  areRegExpsEqual,\n  areSetsEqual,\n  createIsNestedEqual,\n}: CreateComparatorCreatorOptions<Meta>): EqualityComparator<Meta> {\n  const isEqual = createIsNestedEqual(comparator as EqualityComparator<Meta>);\n\n  /**\n   * compare the value of the two objects and return true if they are equivalent in values\n   */\n  function comparator(a: any, b: any, meta: Meta): boolean {\n    // If the items are strictly equal, no need to do a value comparison.\n    if (a === b) {\n      return true;\n    }\n\n    // If the items are not non-nullish objects, then the only possibility\n    // of them being equal but not strictly is if they are both `NaN`. Since\n    // `NaN` is uniquely not equal to itself, we can use self-comparison of\n    // both objects, which is faster than `isNaN()`.\n    if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\n      return a !== a && b !== b;\n    }\n\n    // Checks are listed in order of commonality of use-case:\n    //   1. Common complex object types (plain object, array)\n    //   2. Common data values (date, regexp)\n    //   3. Less-common complex object types (map, set)\n    //   4. Less-common data values (promise, primitive wrappers)\n    // Inherently this is both subjective and assumptive, however\n    // when reviewing comparable libraries in the wild this order\n    // appears to be generally consistent.\n\n    // `isPlainObject` only checks against the object's own realm. Cross-realm\n    // comparisons are rare, and will be handled in the ultimate fallback, so\n    // we can avoid the `toString.call()` cost unless necessary.\n    if (isPlainObject(a) && isPlainObject(b)) {\n      return areObjectsEqual(a, b, isEqual, meta);\n    }\n\n    // `isArray()` works on subclasses and is cross-realm, so we can again avoid\n    // the `toString.call()` cost unless necessary by just checking if either\n    // and then both are arrays.\n    const aArray = Array.isArray(a);\n    const bArray = Array.isArray(b);\n\n    if (aArray || bArray) {\n      return aArray === bArray && areArraysEqual(a, b, isEqual, meta);\n    }\n\n    // Since this is a custom object, use the classic `toString.call()` to get its\n    // type. This is reasonably performant in modern environments like v8 and\n    // SpiderMonkey, and allows for cross-realm comparison when other checks like\n    // `instanceof` do not.\n    const aTag = toString.call(a);\n\n    if (aTag !== toString.call(b)) {\n      return false;\n    }\n\n    if (aTag === DATE_TAG) {\n      // `getTime()` showed better results compared to alternatives like `valueOf()`\n      // or the unary `+` operator.\n      return areDatesEqual(a, b, isEqual, meta);\n    }\n\n    if (aTag === REG_EXP_TAG) {\n      return areRegExpsEqual(a, b, isEqual, meta);\n    }\n\n    if (aTag === MAP_TAG) {\n      return areMapsEqual(a, b, isEqual, meta);\n    }\n\n    if (aTag === SET_TAG) {\n      return areSetsEqual(a, b, isEqual, meta);\n    }\n\n    // If a simple object tag, then we can prioritize a simple object comparison because\n    // it is likely a custom class. If an arguments tag, it should be treated as a standard\n    // object.\n    if (aTag === OBJECT_TAG || aTag === ARGUMENTS_TAG) {\n      // The exception for value comparison is `Promise`-like contracts. These should be\n      // treated the same as standard `Promise` objects, which means strict equality.\n      return isPromiseLike(a) || isPromiseLike(b)\n        ? false\n        : areObjectsEqual(a, b, isEqual, meta);\n    }\n\n    // As the penultimate fallback, check if the values passed are primitive wrappers. This\n    // is very rare in modern JS, which is why it is deprioritized compared to all other object\n    // types.\n    if (aTag === BOOLEAN_TAG || aTag === NUMBER_TAG || aTag === STRING_TAG) {\n      return sameValueZeroEqual(a.valueOf(), b.valueOf());\n    }\n\n    // If not matching any tags that require a specific type of comparison, then we hard-code false because\n    // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\n    //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\n    //     comparison that can be made.\n    //   - For types that can be introspected, but rarely have requirements to be compared\n    //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\n    //     use-cases (may be included in a future release, if requested enough).\n    //   - For types that can be introspected but do not have an objective definition of what\n    //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\n    // In all cases, these decisions should be reevaluated based on changes to the language and\n    // common development practices.\n    return false;\n  }\n\n  return comparator as EqualityComparator<Meta>;\n}\n","import { createIsCircular } from './utils';\n\nimport type { InternalEqualityComparator } from '../index.d';\n\n/**\n * Whether the arrays are equal in value.\n */\nexport function areArraysEqual(\n  a: any[],\n  b: any[],\n  isEqual: InternalEqualityComparator<any>,\n  meta: any,\n): boolean {\n  let index = a.length;\n\n  if (b.length !== index) {\n    return false;\n  }\n\n  // Decrementing `while` showed faster results than either incrementing or\n  // decrementing `for` loop and than an incrementing `while` loop. Declarative\n  // methods like `some` / `every` were not used to avoid incurring the garbage\n  // cost of anonymous callbacks.\n  while (index-- > 0) {\n    if (!isEqual(a[index], b[index], index, index, a, b, meta)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the arrays are equal in value, including circular references.\n */\nexport const areArraysEqualCircular = createIsCircular(areArraysEqual);\n","import { sameValueZeroEqual } from './utils';\n\n/**\n * Whether the dates passed are equal in value.\n *\n * @NOTE\n * This is a standalone function instead of done inline in the comparator\n * to allow for overrides.\n */\nexport function areDatesEqual(a: Date, b: Date): boolean {\n  return sameValueZeroEqual(a.valueOf(), b.valueOf());\n}\n","import { createIsCircular } from './utils';\n\nimport type { InternalEqualityComparator } from '../index.d';\n\n/**\n * Whether the `Map`s are equal in value.\n */\nexport function areMapsEqual(\n  a: Map<any, any>,\n  b: Map<any, any>,\n  isEqual: InternalEqualityComparator<any>,\n  meta: any,\n): boolean {\n  let isValueEqual = a.size === b.size;\n\n  if (!isValueEqual) {\n    return false;\n  }\n\n  if (!a.size) {\n    return true;\n  }\n\n  // The use of `forEach()` is to avoid the transpilation cost of `for...of` comparisons, and\n  // the inability to control the performance of the resulting code. It also avoids excessive\n  // iteration compared to doing comparisons of `keys()` and `values()`. As a result, though,\n  // we cannot short-circuit the iterations; bookkeeping must be done to short-circuit the\n  // equality checks themselves.\n\n  const matchedIndices: Record<number, true> = {};\n\n  let indexA = 0;\n\n  a.forEach((aValue, aKey) => {\n    if (!isValueEqual) {\n      return;\n    }\n\n    let hasMatch = false;\n    let matchIndexB = 0;\n\n    b.forEach((bValue, bKey) => {\n      if (\n        !hasMatch &&\n        !matchedIndices[matchIndexB] &&\n        (hasMatch =\n          isEqual(aKey, bKey, indexA, matchIndexB, a, b, meta) &&\n          isEqual(aValue, bValue, aKey, bKey, a, b, meta))\n      ) {\n        matchedIndices[matchIndexB] = true;\n      }\n\n      matchIndexB++;\n    });\n\n    indexA++;\n    isValueEqual = hasMatch;\n  });\n\n  return isValueEqual;\n}\n\n/**\n * Whether the `Map`s are equal in value, including circular references.\n */\nexport const areMapsEqualCircular = createIsCircular(areMapsEqual);\n","import { createIsCircular } from './utils';\n\nimport type { InternalEqualityComparator } from '../index.d';\n\ninterface Dictionary<Value> {\n  [key: string]: Value;\n  $$typeof?: any;\n}\n\nconst OWNER = '_owner';\nconst { hasOwnProperty } = Object.prototype;\n\n/**\n * Whether the objects are equal in value.\n */\nexport function areObjectsEqual(\n  a: Dictionary<any>,\n  b: Dictionary<any>,\n  isEqual: InternalEqualityComparator<any>,\n  meta: any,\n): boolean {\n  const keysA = Object.keys(a);\n\n  let index = keysA.length;\n\n  if (Object.keys(b).length !== index) {\n    return false;\n  }\n\n  let key: string;\n\n  // Decrementing `while` showed faster results than either incrementing or\n  // decrementing `for` loop and than an incrementing `while` loop. Declarative\n  // methods like `some` / `every` were not used to avoid incurring the garbage\n  // cost of anonymous callbacks.\n  while (index-- > 0) {\n    key = keysA[index];\n\n    if (key === OWNER) {\n      const reactElementA = !!a.$$typeof;\n      const reactElementB = !!b.$$typeof;\n\n      if ((reactElementA || reactElementB) && reactElementA !== reactElementB) {\n        return false;\n      }\n    }\n\n    if (\n      !hasOwnProperty.call(b, key) ||\n      !isEqual(a[key], b[key], key, key, a, b, meta)\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the objects are equal in value, including circular references.\n */\nexport const areObjectsEqualCircular = createIsCircular(areObjectsEqual);\n","/**\n * Whether the regexps passed are equal in value.\n *\n * @NOTE\n * This is a standalone function instead of done inline in the comparator\n * to allow for overrides. An example of this would be supporting a\n * pre-ES2015 environment where the `flags` property is not available.\n */\nexport function areRegExpsEqual(a: RegExp, b: RegExp): boolean {\n  return a.source === b.source && a.flags === b.flags;\n}\n","import { createIsCircular } from './utils';\n\nimport type { InternalEqualityComparator } from '../index.d';\n\n/**\n * Whether the `Set`s are equal in value.\n */\nexport function areSetsEqual(\n  a: Set<any>,\n  b: Set<any>,\n  isEqual: InternalEqualityComparator<any>,\n  meta: any,\n): boolean {\n  let isValueEqual = a.size === b.size;\n\n  if (!isValueEqual) {\n    return false;\n  }\n\n  if (!a.size) {\n    return true;\n  }\n\n  // The use of `forEach()` is to avoid the transpilation cost of `for...of` comparisons, and\n  // the inability to control the performance of the resulting code. It also avoids excessive\n  // iteration compared to doing comparisons of `keys()` and `values()`. As a result, though,\n  // we cannot short-circuit the iterations; bookkeeping must be done to short-circuit the\n  // equality checks themselves.\n\n  const matchedIndices: Record<number, true> = {};\n\n  a.forEach((aValue, aKey) => {\n    if (!isValueEqual) {\n      return;\n    }\n\n    let hasMatch = false;\n    let matchIndex = 0;\n\n    b.forEach((bValue, bKey) => {\n      if (\n        !hasMatch &&\n        !matchedIndices[matchIndex] &&\n        (hasMatch = isEqual(aValue, bValue, aKey, bKey, a, b, meta))\n      ) {\n        matchedIndices[matchIndex] = true;\n      }\n\n      matchIndex++;\n    });\n\n    isValueEqual = hasMatch;\n  });\n\n  return isValueEqual;\n}\n\n/**\n * Whether the `Set`s are equal in value, including circular references.\n */\nexport const areSetsEqualCircular = createIsCircular(areSetsEqual);\n","import { createComparator } from './comparator';\nimport { areArraysEqual, areArraysEqualCircular } from './arrays';\nimport { areDatesEqual } from './dates';\nimport { areMapsEqual, areMapsEqualCircular } from './maps';\nimport { areObjectsEqual, areObjectsEqualCircular } from './objects';\nimport { areRegExpsEqual } from './regexps';\nimport { areSetsEqual, areSetsEqualCircular } from './sets';\nimport { createDefaultIsNestedEqual, merge, sameValueZeroEqual } from './utils';\n\nimport type {\n  BaseCircularMeta,\n  CreateComparatorCreatorOptions,\n  EqualityComparator,\n  GetComparatorOptions,\n} from '../index.d';\n\nexport { sameValueZeroEqual };\n\nconst DEFAULT_CONFIG: CreateComparatorCreatorOptions<undefined> = Object.freeze(\n  {\n    areArraysEqual,\n    areDatesEqual,\n    areMapsEqual,\n    areObjectsEqual,\n    areRegExpsEqual,\n    areSetsEqual,\n    createIsNestedEqual: createDefaultIsNestedEqual,\n  },\n);\nconst DEFAULT_CIRCULAR_CONFIG: CreateComparatorCreatorOptions<BaseCircularMeta> =\n  Object.freeze({\n    areArraysEqual: areArraysEqualCircular,\n    areDatesEqual,\n    areMapsEqual: areMapsEqualCircular,\n    areObjectsEqual: areObjectsEqualCircular,\n    areRegExpsEqual,\n    areSetsEqual: areSetsEqualCircular,\n    createIsNestedEqual: createDefaultIsNestedEqual,\n  });\n\nconst isDeepEqual = createComparator(DEFAULT_CONFIG);\n\n/**\n * Whether the items passed are deeply-equal in value.\n */\nexport function deepEqual<A, B>(a: A, b: B): boolean {\n  return isDeepEqual(a, b, undefined);\n}\n\nconst isShallowEqual = createComparator(\n  merge(DEFAULT_CONFIG, { createIsNestedEqual: () => sameValueZeroEqual }),\n);\n\n/**\n * Whether the items passed are shallowly-equal in value.\n */\nexport function shallowEqual<A, B>(a: A, b: B): boolean {\n  return isShallowEqual(a, b, undefined);\n}\n\nconst isCircularDeepEqual = createComparator(DEFAULT_CIRCULAR_CONFIG);\n\n/**\n * Whether the items passed are deeply-equal in value, including circular references.\n */\nexport function circularDeepEqual<A, B>(a: A, b: B): boolean {\n  return isCircularDeepEqual(a, b, new WeakMap());\n}\n\nconst isCircularShallowEqual = createComparator(\n  merge(DEFAULT_CIRCULAR_CONFIG, {\n    createIsNestedEqual: () => sameValueZeroEqual,\n  }),\n);\n\n/**\n * Whether the items passed are shallowly-equal in value, including circular references.\n */\nexport function circularShallowEqual<A, B>(a: A, b: B): boolean {\n  return isCircularShallowEqual(a, b, new WeakMap());\n}\n\n/**\n * Create a custom equality comparison method.\n *\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\n * where the standard methods are not performant enough, but can also be used to provide\n * support for legacy environments that do not support expected features like\n * `RegExp.prototype.flags` out of the box.\n */\nexport function createCustomEqual<Meta = undefined>(\n  getComparatorOptions: GetComparatorOptions<Meta>,\n): EqualityComparator<Meta> {\n  return createComparator<Meta>(\n    merge(DEFAULT_CONFIG, getComparatorOptions(DEFAULT_CONFIG as any)),\n  );\n}\n\n/**\n * Create a custom equality comparison method that handles circular references. This is very\n * similar to `createCustomEqual`, with the only difference being that `meta` expects to be\n * populated with a `WeakMap`-like contract.\n *\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\n * where the standard methods are not performant enough, but can also be used to provide\n * support for legacy environments that do not support expected features like\n * `WeakMap` out of the box.\n */\nexport function createCustomCircularEqual<\n  Meta extends BaseCircularMeta = WeakMap<any, any>,\n>(getComparatorOptions: GetComparatorOptions<Meta>): EqualityComparator<Meta> {\n  const comparator = createComparator<Meta>(\n    merge(\n      DEFAULT_CIRCULAR_CONFIG,\n      getComparatorOptions(DEFAULT_CIRCULAR_CONFIG as any),\n    ),\n  );\n\n  return ((a: any, b: any, meta: any = new WeakMap()) =>\n    comparator(a, b, meta)) as EqualityComparator<Meta>;\n}\n"]},"metadata":{},"sourceType":"script"}